\"\"\"Compiles nodes from the parser into Python code.\"\"\"\nimport typing as t\nfrom contextlib import contextmanager\nfrom functools import update_wrapper\nfrom io import StringIO\nfrom itertools import chain\nfrom keyword import iskeyword as is_python_keyword\n\nfrom markupsafe import escape\nfrom markupsafe import Markup\n\nfrom . import nodes\nfrom .exceptions import TemplateAssertionError\nfrom .idtracking import Symbols\nfrom .idtracking import VAR_LOAD_ALIAS\nfrom .idtracking import VAR_LOAD_PARAMETER\nfrom .idtracking import VAR_LOAD_RESOLVE\nfrom .idtracking import VAR_LOAD_UNDEFINED\nfrom .nodes import EvalContext\nfrom .optimizer import Optimizer\nfrom .utils import _PassArg\nfrom .utils import concat\nfrom .visitor import NodeVisitor\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n    from .environment import Environment\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\noperators = {\n    \"eq\": \"==\",\n    \"ne\": \"!=\",\n    \"gt\": \">\",\n    \"gteq\": \">=\",\n    \"lt\": \"<\",\n    \"lteq\": \"<=\",\n    \"in\": \"in\",\n    \"notin\": \"not in\",\n}\n\ndef optimizeconst(f: F) -> F:\n    def new_func(\n        self: \"CodeGenerator\", node: nodes.Expr, frame: \"Frame\", **kwargs: t.Any\n    ) -> t.Any:\n        # Only optimize if the frame is not volatile\n        if self.optimizer is not None and not frame.eval_ctx.volatile:\n            new_node = self.optimizer.visit(node, frame.eval_ctx)\n\n            if new_node != node:\n                return self.visit(new_node, frame)\n\n        return f(self, node, frame, **kwargs)\n\n    return update_wrapper(t.cast(F, new_func), f)\n\ndef _make_binop(op: str) -> t.Callable[[\"CodeGenerator\", nodes.BinExpr, \"Frame\"], None]:\n    @optimizeconst\n    def visitor(self: \"CodeGenerator\", node: nodes.BinExpr, frame: Frame) -> None:\n        if (\n            self.environment.sandboxed\n            and op in self.environment.intercepted_binops  # type: ignore\n        ):\n            self.write(f\"environment.call_binop(context, {op!r}, \")\n            self.visit(node.left, frame)\n            self.write(\", \")\n            self.visit(node.right, frame)\n        else:\n            self.write(\"(\")\n            self.visit(node.left, frame)\n            self.write(f\" {op} \")\n            self.visit(node.right, frame)\n\n        self.write(\")\")\n\n    return visitor\n\ndef _make_unop(\n    op: str,\n) -> t.Callable[[\"CodeGenerator\", nodes.UnaryExpr, \"Frame\"], None]:\n    @optimizeconst\n    def visitor(self: \"CodeGenerator\", node: nodes.UnaryExpr, frame: Frame) -> None:\n        if (\n            self.environment.sandboxed\n            and op in self.environment.intercepted_unops  # type: ignore\n        ):\n            self.write(f\"environment.call_unop(context, {op!r}, \")\n            self.visit(node.node, frame)\n        else:\n            self.write(\"(\" + op)\n            self.visit(node.node, frame)\n\n        self.write(\")\")\n\n    return visitor\n\ndef generate(\n    node: nodes.Template,\n    environment: \"Environment\",\n    name: t.Optional[str],\n    filename: t.Optional[str],\n    stream: t.Optional[t.TextIO] = None,\n    defer_init: bool = False,\n    optimized: bool = True,\n) -> t.Optional[str]:\n    \"\"\"Generate the python source for a node tree.\"\"\"\n    if not isinstance(node, nodes.Template):\n        raise TypeError(\"Can't compile non template nodes\")\n\n    generator = environment.code_generator_class(\n        environment, name, filename, stream, defer_init, optimized\n    )\n    generator.visit(node)\n\n    if stream is None:\n        return generator.stream.getvalue()  # type: ignore\n\n    return None\n\ndef has_safe_repr(value: t.Any) -> bool:\n    \"\"\"Does the node have a safe representation?\"\"\"\n    if value is None or value is NotImplemented or value is Ellipsis:\n        return True\n\n    if type(value) in {bool, int, float, complex, range, str, Markup}:\n        return True\n\n    if type(value) in {tuple, list, set, frozenset}:\n        return all(has_safe_repr(v) for v in value)\n\n    if type(value) is dict:\n        return all(has_safe_repr(k) and has_safe_repr(v) for k, v in value.items())\n\n    return False\n\ndef find_undeclared(\n    nodes: t.Iterable[nodes.Node], names: t.Iterable[str]\n) -> t.Set[str]:\n    \"\"\"Check if the names passed are accessed undeclared.  The return value\n    is a set of all the undeclared names from the sequence of names found.\n    \"\"\"\n    visitor = UndeclaredNameVisitor(names)\n    try:\n        for node in nodes:\n            visitor.visit(node)\n    except VisitorExit:\n        pass\n    return visitor.undeclared\n\nclass MacroRef:\n    def __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -> None:\n        self.node = node\n        self.accesses_caller = False\n        self.accesses_kwargs = False\n        self.accesses_varargs = False\n\nclass Frame:\n    \"\"\"Holds compile time information for us.\"\"\"\n\n    def __init__(\n        self,\n        eval_ctx: EvalContext,\n        parent: t.Optional[\"Frame\"] = None,\n        level: t.Optional[int] = None,\n    ) -> None:\n        self.eval_ctx = eval_ctx\n\n        # the parent of this frame\n        self.parent = parent\n\n        if parent is None:\n            self.symbols = Symbols(level=level)\n\n            # in some dynamic inheritance situations the compiler needs to add\n            # write tests around output statements.\n            self.require_output_check = False\n\n            # inside some tags we are using a buffer rather than yield statements.\n            # this for example affects {% filter %} or {% macro %}.  If a frame\n            # is buffered this variable points to the name of the list used as\n            # buffer.\n            self.buffer: t.Optional[str] = None\n\n            # the name of the block we're in, otherwise None.\n            self.block: t.Optional[str] = None\n\n        else:\n            self.symbols = Symbols(parent.symbols, level=level)\n            self.require_output_check = parent.require_output_check\n            self.buffer = parent.buffer\n            self.block = parent.block\n\n        # a toplevel frame is the root + soft frames such as if conditions.\n        self.toplevel = False\n\n        # the root frame is basically just the outermost frame, so no if\n        # conditions.  This information is used to optimize inheritance\n        # situations.\n        self.rootlevel = False\n\n        # variables set inside of loops and blocks should not affect outer frames,\n        # but they still needs to be kept track of as part of the active context.\n        self.loop_frame = False\n        self.block_frame = False\n\n        # track whether the frame is being used in an if-statement or conditional\n        # expression as it determines which errors should be raised during runtime\n        # or compile time.\n        self.soft_frame = False\n\n    def copy(self) -> \"Frame\":\n        \"\"\"Create a copy of the current one.\"\"\"\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.symbols = self.symbols.copy()\n        return rv\n\n    def inner(self, isolated: bool = False) -> \"Frame\":\n        \"\"\"Return an inner frame.\"\"\"\n        if isolated:\n            return Frame(self.eval_ctx, level=self.symbols.level + 1)\n        return Frame(self.eval_ctx, self)\n\n    def soft(self) -> \"Frame\":\n        \"\"\"Return a soft frame.  A soft frame may not be modified as\n        standalone thing as it shares the resources with the frame it\n        was created of, but it's not a rootlevel frame any longer.\n\n        This is only used to implement if-statements and conditional\n        expressions.\n        \"\"\"\n        rv = self.copy()\n        rv.rootlevel = False\n        rv.soft_frame = True\n        return rv\n\n    __copy__ = copy\n\nclass VisitorExit(RuntimeError):\n    \"\"\"Exception used by the `UndeclaredNameVisitor` to signal a stop.\"\"\"\n\nclass DependencyFinderVisitor(NodeVisitor):\n    \"\"\"A visitor that collects filter and test calls.\"\"\"\n\n    def __init__(self) -> None:\n        self.filters: t.Set[str] = set()\n        self.tests: t.Set[str] = set()\n\n    def visit_Filter(self, node: nodes.Filter) -> None:\n        self.generic_visit(node)\n        self.filters.add(node.name)\n\n    def visit_Test(self, node: nodes.Test) -> None:\n        self.generic_visit(node)\n        self.tests.add(node.name)\n\n    def visit_Block(self, node: nodes.Block) -> None:\n        \"\"\"Stop visiting at blocks.\"\"\"\n\nclass UndeclaredNameVisitor(NodeVisitor):\n    \"\"\"A visitor that checks if a name is accessed without being\n    declared.  This is different from the frame visitor as it will\n    not stop at closure frames.\n    \"\"\"\n\n    def __init__(self, names: t.Iterable[str]) -> None:\n        self.names = set(names)\n        self.undeclared: t.Set[str] = set()\n\n    def visit_Name(self, node: nodes.Name) -> None:\n        if node.ctx == \"load\" and node.name in self.names:\n            self.undeclared.add(node.name)\n            if self.undeclared == self.names:\n                raise VisitorExit()\n        else:\n            self.names.discard(node.name)\n\n    def visit_Block(self, node: nodes.Block) -> None:\n        \"\"\"Stop visiting a blocks.\"\"\"\n\nclass CompilerExit(Exception):\n    \"\"\"Raised if the compiler encountered a situation where it just\n    doesn't make sense to further process the code.  Any block that\n    raises such an exception is not further processed.\n    \"\"\"\n\nclass CodeGenerator(NodeVisitor):\n    def __init__(\n        self,\n        environment: \"Environment\",\n        name: t.Optional[str],\n        filename: t.Optional[str],\n        stream: t.Optional[t.TextIO] = None,\n        defer_init: bool = False,\n        optimized: bool = True,\n    ) -> None:\n        if stream is None:\n            stream = StringIO()\n        self.environment = environment\n        self.name = name\n        self.filename = filename\n        self.stream = stream\n        self.created_block_context = False\n        self.defer_init = defer_init\n        self.optimizer: t.Optional[Optimizer] = None\n\n        if optimized:\n            self.optimizer = Optimizer(environment)\n\n        # aliases for imports\n        self.import_aliases: t.Dict[str, str] = {}\n\n        # a registry for all blocks.  Because blocks are moved out\n        # into the global python scope they are registered here\n        self.blocks: t.Dict[str, nodes.Block] = {}\n\n        # the number of extends statements so far\n        self.extends_so_far = 0\n\n        # some templates have a rootlevel extends.  In this case we\n        # can safely assume that we're a child template and do some\n        # more optimizations.\n        self.has_known_extends = False\n\n        # the current line number\n        self.code_lineno = 1\n\n        # registry of all filters and tests (global, not block local)\n        self.tests: t.Dict[str, str] = {}\n        self.filters: t.Dict[str, str] = {}\n\n        # the debug information\n        self.debug_info: t.List[t.Tuple[int, int]] = []\n        self._write_debug_info: t.Optional[int] = None\n\n        # the number of new lines before the next write()\n        self._new_lines = 0\n\n        # the line number of the last written statement\n        self._last_line = 0\n\n        # true if nothing was written so far.\n        self._first_write = True\n\n        # used by the `temporary_identifier` method to get new\n        # unique, temporary identifier\n        self._last_identifier = 0\n\n        # the current indentation\n        self._indentation = 0\n\n        # Tracks toplevel assignments\n        self._assign_stack: t.List[t.Set[str]] = []\n\n        # Tracks parameter definition blocks\n        self._param_def_block: t.List[t.Set[str]] = []\n\n        # Tracks the current context.\n        self._context_reference_stack = [\"context\"]\n\n    @property\n    def optimized(self) -> bool:\n        return self.optimizer is not None\n\n    # -- Various compilation helpers\n\n    def fail(self, msg: str, lineno: int) -> \"te.NoReturn\":\n        \"\"\"Fail with a :exc:`TemplateAssertionError`.\"\"\"\n        raise TemplateAssertionError(msg, lineno, self.name, self.filename)\n\n    def temporary_identifier(self) -> str:\n        \"\"\"Get a new unique identifier.\"\"\"\n        self._last_identifier += 1\n        return f\"t_{self._last_identifier}\"\n\n    def buffer(self, frame: Frame) -> None:\n        \"\"\"Enable buffering for the frame from that point onwards.\"\"\"\n        frame.buffer = self.temporary_identifier()\n        self.writeline(f\"{frame.buffer} = []\")\n\n    def return_buffer_contents(\n        self, frame: Frame, force_unescaped: bool = False\n    ) -> None:\n        \"\"\"Return the buffer contents of the frame.\"\"\"\n        if not force_unescaped:\n            if frame.eval_ctx.volatile:\n                self.writeline(\"if context.eval_ctx.autoescape:\")\n                self.indent()\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                self.outdent()\n                self.writeline(\"else:\")\n                self.indent()\n                self.writeline(f\"return concat({frame.buffer})\")\n                self.outdent()\n                return\n            elif frame.eval_ctx.autoescape:\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                return\n        self.writeline(f\"return concat({frame.buffer})\")\n\n    def indent(self) -> None:\n        \"\"\"Indent by one.\"\"\"\n        self._indentation += 1\n\n    def outdent(self, step: int = 1) -> None:\n        \"\"\"Outdent by step.\"\"\"\n        self._indentation -= step\n\n    def start_write(self, frame: Frame, node: t.Optional[nodes.Node] = None) -> None:\n        \"\"\"Yield or write into the frame buffer.\"\"\"\n        if frame.buffer is None:\n            self.writeline(\"yield \", node)\n        else:\n            self.writeline(f\"{frame.buffer}.append(\", node)\n\n    def end_write(self, frame: Frame) -> None:\n        \"\"\"End the writing process started by `start_write`.\"\"\"\n        if frame.buffer is not None:\n            self.write(\")\")\n\n    def simple_write(\n        self, s: str, frame: Frame, node: t.Optional[nodes.Node] = None\n    ) -> None:\n        \"\"\"Simple shortcut for start_write + write + end_write.\"\"\"\n        self.start_write(frame, node)\n        self.write(s)\n        self.end_write(frame)\n\n    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -> None:\n        \"\"\"Visit a list of nodes as block in a frame.  If the current frame\n        is no buffer a dummy ``if 0: yield None`` is written automatically.\n        \"\"\"\n        try:\n            self.writeline(\"pass\")\n            for node in nodes:\n                self.visit(node, frame)\n        except CompilerExit:\n            pass\n\n    def write(self, x: str) -> None:\n        \"\"\"Write a string into the output stream.\"\"\"\n        if self._new_lines:\n            if not self._first_write:\n                self.stream.write(\"\\n\" * self._new_lines)\n                self.code_lineno += self._new_lines\n                if self._write_debug_info is not None:\n                    self.debug_info.append((self._write_debug_info, self.code_lineno))\n                    self._write_debug_info = None\n            self._first_write = False\n            self.stream.write(\"    \" * self._indentation)\n            self._new_lines = 0\n        self.stream.write(x)\n\n    def writeline(\n        self, x: str, node: t.Optional[nodes.Node] = None, extra: int = 0\n    ) -> None:\n        \"\"\"Combination of newline and write.\"\"\"\n        self.newline(node, extra)\n        self.write(x)\n\n    def newline(self, node: t.Optional[nodes.Node] = None, extra: int = 0) -> None:\n        \"\"\"Add one or more newlines before the next write.\"\"\"\n        self._new_lines = max(self._new_lines, 1 + extra)\n        if node is not None and node.lineno != self._last_line:\n            self._write_debug_info = node.lineno\n            self._last_line = node.lineno\n\n    def signature(\n        self,\n        node: t.Union[nodes.Call, nodes.Filter, nodes.Test],\n        frame: Frame,\n        extra_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,\n    ) -> None:\n        \"\"\"Writes a function call to the stream for the current node.\n        A leading comma is added automatically.  The extra keyword\n        arguments may not include python keywords otherwise a syntax\n        error could occur.  The extra keyword arguments should be given\n        as python dict.\n        \"\"\"\n        # if any of the given keyword arguments is a python keyword\n        # we have to make sure that no invalid call is created.\n        kwarg_workaround = any(\n            is_python_keyword(t.cast(str, k))\n            for k in chain((x.key for x in node.kwargs), extra_kwargs or ())\n        )\n\n        for arg in node.args:\n            self.write(\", \")\n            self.visit(arg, frame)\n\n        if not kwarg_workaround:\n            for kwarg in node.kwargs:\n                self.write(\", \")\n                self.visit(kwarg, frame)\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\", {key}={value}\")\n        if node.dyn_args:\n            self.write(\", *\")\n            self.visit(node.dyn_args, frame)\n\n        if kwarg_workaround:\n            if node.dyn_kwargs is not None:\n                self.write(\", **dict({\")\n            else:\n                self.write(\", **{\")\n            for kwarg in node.kwargs:\n                self.write(f\"{kwarg.key!r}: \")\n                self.visit(kwarg.value, frame)\n                self.write(\", \")\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\"{key!r}: {value}, \")\n            if node.dyn_kwargs is not None:\n                self.write(\"}, **\")\n                self.visit(node.dyn_kwargs, frame)\n                self.write(\")\")\n            else:\n                self.write(\"}\")\n\n        elif node.dyn_kwargs is not None:\n            self.write(\", **\")\n            self.visit(node.dyn_kwargs, frame)\n\n    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -> None:\n        \"\"\"Find all filter and test names used in the template and\n        assign them to variables in the compiled namespace. Checking\n        that the names are registered with the environment is done when\n        compiling the Filter and Test nodes. If the node is in an If or\n        CondExpr node, the check is done at runtime instead.\n\n        .. versionchanged:: 3.0\n            Filters and tests in If and CondExpr nodes are checked at\n            runtime instead of compile time.\n        \"\"\"\n        visitor = DependencyFinderVisitor()\n\n        for node in nodes:\n            visitor.visit(node)\n\n        for id_map, names, dependency in (self.filters, visitor.filters, \"filters\"), (\n            self.tests,\n            visitor.tests,\n            \"tests\",\n        ):\n            for name in sorted(names):\n                if name not in id_map:\n                    id_map[name] = self.temporary_identifier()\n\n                # add check during runtime that dependencies used inside of executed\n                # blocks are defined, as this step may be skipped during compile time\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(f\"{id_map[name]} = environment.{dependency}[{name!r}]\")\n                self.outdent()\n                self.writeline(\"except KeyError:\")\n                self.indent()\n                self.writeline(\"@internalcode\")\n                self.writeline(f\"def {id_map[name]}(*unused):\")\n                self.indent()\n                self.writeline(\n                    f'raise TemplateRuntimeError(\"No {dependency[:-1]}'\n                    f' named {name!r} found.\")'\n                )\n                self.outdent()\n                self.outdent()\n\n    def enter_frame(self, frame: Frame) -> None:\n        undefs = []\n        for target, (action, param) in frame.symbols.loads.items():\n            if action == VAR_LOAD_PARAMETER:\n                pass\n            elif action == VAR_LOAD_RESOLVE:\n                self.writeline(f\"{target} = {self.get_resolve_func()}({param!r})\")\n            elif action == VAR_LOAD_ALIAS:\n                self.writeline(f\"{target} = {param}\")\n            elif action == VAR_LOAD_UNDEFINED:\n                undefs.append(target)\n            else:\n                raise NotImplementedError(\"unknown load instruction\")\n        if undefs:\n            self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def leave_frame(self, frame: Frame, with_python_scope: bool = False) -> None:\n        if not with_python_scope:\n            undefs = []\n            for target in frame.symbols.loads:\n                undefs.append(target)\n            if undefs:\n                self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def choose_async(self, async_value: str = \"async \", sync_value: str = \"\") -> str:\n        return async_value if self.environment.is_async else sync_value\n\n    def func(self, name: str) -> str:\n        return f\"{self.choose_async()}def {name}\"\n\n    def macro_body(\n        self, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame\n    ) -> t.Tuple[Frame, MacroRef]:\n        \"\"\"Dump the function def of a macro or call block.\"\"\"\n        frame = frame.inner()\n        frame.symbols.analyze_node(node)\n        macro_ref = MacroRef(node)\n\n        explicit_caller = None\n        skip_special_params = set()\n        args = []\n\n        for idx, arg in enumerate(node.args):\n            if arg.name == \"caller\":\n                explicit_caller = idx\n            if arg.name in (\"kwargs\", \"varargs\"):\n                skip_special_params.add(arg.name)\n            args.append(frame.symbols.ref(arg.name))\n\n        undeclared = find_undeclared(node.body, (\"caller\", \"kwargs\", \"varargs\"))\n\n        if \"caller\" in undeclared:\n            # In older Jinja versions there was a bug that allowed caller\n            # to retain the special behavior even if it was mentioned in\n            # the argument list.  However thankfully this was only really\n            # working if it was the last argument.  So we are explicitly\n            # checking this now and error out if it is anywhere else in\n            # the argument list.\n            if explicit_caller is not None:\n                try:\n                    node.defaults[explicit_caller - len(node.args)]\n                except IndexError:\n                    self.fail(\n                        \"When defining macros or call blocks the \"\n                        'special \"caller\" argument must be omitted '\n                        \"or be given a default.\",\n                        node.lineno,\n                    )\n            else:\n                args.append(frame.symbols.declare_parameter(\"caller\"))\n            macro_ref.accesses_caller = True\n        if \"kwargs\" in undeclared and \"kwargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"kwargs\"))\n            macro_ref.accesses_kwargs = True\n        if \"varargs\" in undeclared and \"varargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"varargs\"))\n            macro_ref.accesses_varargs = True\n\n        # macros are delayed, they never require output checks\n        frame.require_output_check = False\n        frame.symbols.analyze_node(node)\n        self.writeline(f\"{self.func('macro')}({', '.join(args)}):\", node)\n        self.indent()\n\n        self.buffer(frame)\n        self.enter_frame(frame)\n\n        self.push_parameter_definitions(frame)\n        for idx, arg in enumerate(node.args):\n            ref = frame.symbols.ref(arg.name)\n            self.writeline(f\"if {ref} is missing:\")\n            self.indent()\n            try:\n                default = node.defaults[idx - len(node.args)]\n            except IndexError:\n                self.writeline(\n                    f'{ref} = undefined(\"parameter {arg.name!r} was not provided\",'\n                    f\" name={arg.name!r})\"\n                )\n            else:\n                self.writeline(f\"{ref} = \")\n                self.visit(default, frame)\n            self.mark_parameter_stored(ref)\n            self.outdent()\n        self.pop_parameter_definitions()\n\n        self.blockvisit(node.body, frame)\n        self.return_buffer_contents(frame, force_unescaped=True)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        return frame, macro_ref\n\n    def macro_def(self, macro_ref: MacroRef, frame: Frame) -> None:\n        \"\"\"Dump the macro definition for the def created by macro_body.\"\"\"\n        arg_tuple = \", \".join(repr(x.name) for x in macro_ref.node.args)\n        name = getattr(macro_ref.node, \"name\", None)\n        if len(macro_ref.node.args) == 1:\n            arg_tuple += \",\"\n        self.write(\n            f\"Macro(environment, macro, {name!r}, ({arg_tuple}),\"\n            f\" {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},\"\n            f\" {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)\"\n        )\n\n    def position(self, node: nodes.Node) -> str:\n        \"\"\"Return a human readable position for the node.\"\"\"\n        rv = f\"line {node.lineno}\"\n        if self.name is not None:\n            rv = f\"{rv} in {self.name!r}\"\n        return rv\n\n    def dump_local_context(self, frame: Frame) -> str:\n        items_kv = \", \".join(\n            f\"{name!r}: {target}\"\n            for name, target in frame.symbols.dump_stores().items()\n        )\n        return f\"{{{items_kv}}}\"\n\n    def write_commons(self) -> None:\n        \"\"\"Writes a common preamble that is used by root and block functions.\n        Primarily this sets up common local helpers and enforces a generator\n        through a dead branch.\n        \"\"\"\n        self.writeline(\"resolve = context.resolve_or_missing\")\n        self.writeline(\"undefined = environment.undefined\")\n        self.writeline(\"concat = environment.concat\")\n        # always use the standard Undefined class for the implicit else of\n        # conditional expressions\n        self.writeline(\"cond_expr_undefined = Undefined\")\n        self.writeline(\"if 0: yield None\")\n\n    def push_parameter_definitions(self, frame: Frame) -> None:\n        \"\"\"Pushes all parameter targets from the given frame into a local\n        stack that permits tracking of yet to be assigned parameters.  In\n        particular this enables the optimization from `visit_Name` to skip\n        undefined expressions for parameters in macros as macros can reference\n        otherwise unbound parameters.\n        \"\"\"\n        self._param_def_block.append(frame.symbols.dump_param_targets())\n\n    def pop_parameter_definitions(self) -> None:\n        \"\"\"Pops the current parameter definitions set.\"\"\"\n        self._param_def_block.pop()\n\n    def mark_parameter_stored(self, target: str) -> None:\n        \"\"\"Marks a parameter in the current parameter definitions as stored.\n        This will skip the enforced undefined checks.\n        \"\"\"\n        if self._param_def_block:\n            self._param_def_block[-1].discard(target)\n\n    def push_context_reference(self, target: str) -> None:\n        self._context_reference_stack.append(target)\n\n    def pop_context_reference(self) -> None:\n        self._context_reference_stack.pop()\n\n    def get_context_ref(self) -> str:\n        return self._context_reference_stack[-1]\n\n    def get_resolve_func(self) -> str:\n        target = self._context_reference_stack[-1]\n        if target == \"context\":\n            return \"resolve\"\n        return f\"{target}.resolve\"\n\n    def derive_context(self, frame: Frame) -> str:\n        return f\"{self.get_context_ref()}.derived({self.dump_local_context(frame)})\"\n\n    def parameter_is_undeclared(self, target: str) -> bool:\n        \"\"\"Checks if a given target is an undeclared parameter.\"\"\"\n        if not self._param_def_block:\n            return False\n        return target in self._param_def_block[-1]\n\n    def push_assign_tracking(self) -> None:\n        \"\"\"Pushes a new layer for assignment tracking.\"\"\"\n        self._assign_stack.append(set())\n\n    def pop_assign_tracking(self, frame: Frame) -> None:\n        \"\"\"Pops the topmost level for assignment tracking and updates the\n        context variables if necessary.\n        \"\"\"\n        vars = self._assign_stack.pop()\n        if (\n            not frame.block_frame\n            and not frame.loop_frame\n            and not frame.toplevel\n            or not vars\n        ):\n            return\n        public_names = [x for x in vars if x[:1] != \"_\"]\n        if len(vars) == 1:\n            name = next(iter(vars))\n            ref = frame.symbols.ref(name)\n            if frame.loop_frame:\n                self.writeline(f\"_loop_vars[{name!r}] = {ref}\")\n                return\n            if frame.block_frame:\n                self.writeline(f\"_block_vars[{name!r}] = {ref}\")\n                return\n            self.writeline(f\"context.vars[{name!r}] = {ref}\")\n        else:\n            if frame.loop_frame:\n                self.writeline(\"_loop_vars.update({\")\n            elif frame.block_frame:\n                self.writeline(\"_block_vars.update({\")\n            else:\n                self.writeline(\"context.vars.update({\")\n            for idx, name in enumerate(vars):\n                if idx:\n                    self.write(\", \")\n                ref = frame.symbols.ref(name)\n                self.write(f\"{name!r}: {ref}\")\n            self.write(\"})\")\n        if not frame.block_frame and not frame.loop_frame and public_names:\n            if len(public_names) == 1:\n                self.writeline(f\"context.exported_vars.add({public_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, public_names))\n                self.writeline(f\"context.exported_vars.update(({names_str}))\")\n\n    # -- Statement Visitors\n\n    def visit_Template(\n        self, node: nodes.Template, frame: t.Optional[Frame] = None\n    ) -> None:\n        assert frame is None, \"no root frame allowed\"\n        eval_ctx = EvalContext(self.environment, self.name)\n\n        from .runtime import exported, async_exported\n\n        if self.environment.is_async:\n            exported_names = sorted(exported + async_exported)\n        else:\n            exported_names = sorted(exported)\n\n        self.writeline(\"from jinja2.runtime import \" + \", \".join(exported_names))\n\n        # if we want a deferred initialization we cannot move the\n        # environment into a local name\n        envenv = \"\" if self.defer_init else \", environment=environment\"\n\n        # do we have an extends tag at all?  If not, we can save some\n        # overhead by just not processing any inheritance code.\n        have_extends = node.find(nodes.Extends) is not None\n\n        # find all blocks\n        for block in node.find_all(nodes.Block):\n            if block.name in self.blocks:\n                self.fail(f\"block {block.name!r} defined twice\", block.lineno)\n            self.blocks[block.name] = block\n\n        # find all imports and import them\n        for import_ in node.find_all(nodes.ImportedName):\n            if import_.importname not in self.import_aliases:\n                imp = import_.importname\n                self.import_aliases[imp] = alias = self.temporary_identifier()\n                if \".\" in imp:\n                    module, obj = imp.rsplit(\".\", 1)\n                    self.writeline(f\"from {module} import {obj} as {alias}\")\n                else:\n                    self.writeline(f\"import {imp} as {alias}\")\n\n        # add the load name\n        self.writeline(f\"name = {self.name!r}\")\n\n        # generate the root render function.\n        self.writeline(\n            f\"{self.func('root')}(context, missing=missing{envenv}):\", extra=1\n        )\n        self.indent()\n        self.write_commons()\n\n        # process the root\n        frame = Frame(eval_ctx)\n        if \"self\" in find_undeclared(node.body, (\"self\",)):\n            ref = frame.symbols.declare_parameter(\"self\")\n            self.writeline(f\"{ref} = TemplateReference(context)\")\n        frame.symbols.analyze_node(node)\n        frame.toplevel = frame.rootlevel = True\n        frame.require_output_check = have_extends and not self.has_known_extends\n        if have_extends:\n            self.writeline(\"parent_template = None\")\n        self.enter_frame(frame)\n        self.pull_dependencies(node.body)\n        self.blockvisit(node.body, frame)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        # make sure that the parent root is called.\n        if have_extends:\n            if not self.has_known_extends:\n                self.indent()\n                self.writeline(\"if parent_template is not None:\")\n            self.indent()\n            if not self.environment.is_async:\n                self.writeline(\"yield from parent_template.root_render_func(context)\")\n            else:\n                self.writeline(\n                    \"async for event in parent_template.root_render_func(context):\"\n                )\n                self.indent()\n                self.writeline(\"yield event\")\n                self.outdent()\n            self.outdent(1 + (not self.has_known_extends))\n\n        # at this point we now have the blocks collected and can visit them too.\n        for name, block in self.blocks.items():\n            self.writeline(\n                f\"{self.func('block_' + name)}(context, missing=missing{envenv}):\",\n                block,\n                1,\n            )\n            self.indent()\n            self.write_commons()\n            # It's important that we do not make this frame a child of the\n            # toplevel template.  This would cause a variety of\n            # interesting issues with identifier tracking.\n            block_frame = Frame(eval_ctx)\n            block_frame.block_frame = True\n            undeclared = find_undeclared(block.body, (\"self\", \"super\"))\n            if \"self\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"self\")\n                self.writeline(f\"{ref} = TemplateReference(context)\")\n            if \"super\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"super\")\n                self.writeline(f\"{ref} = context.super({name!r}, block_{name})\")\n            block_frame.symbols.analyze_node(block)\n            block_frame.block = name\n            self.writeline(\"_block_vars = {}\")\n            self.enter_frame(block_frame)\n            self.pull_dependencies(block.body)\n            self.blockvisit(block.body, block_frame)\n            self.leave_frame(block_frame, with_python_scope=True)\n            self.outdent()\n\n        blocks_kv_str = \", \".join(f\"{x!r}: block_{x}\" for x in self.blocks)\n        self.writeline(f\"blocks = {{{blocks_kv_str}}}\", extra=1)\n        debug_kv_str = \"&\".join(f\"{k}={v}\" for k, v in self.debug_info)\n        self.writeline(f\"debug_info = {debug_kv_str!r}\")\n\n    def visit_Block(self, node: nodes.Block, frame: Frame) -> None:\n        \"\"\"Call a block and register it for the template.\"\"\"\n        level = 0\n        if frame.toplevel:\n            # if we know that we are a child template, there is no need to\n            # check if we are one\n            if self.has_known_extends:\n                return\n            if self.extends_so_far > 0:\n                self.writeline(\"if parent_template is None:\")\n                self.indent()\n                level += 1\n\n        if node.scoped:\n            context = self.derive_context(frame)\n        else:\n            context = self.get_context_ref()\n\n        if node.required:\n            self.writeline(f\"if len(context.blocks[{node.name!r}]) <= 1:\", node)\n            self.indent()\n            self.writeline(\n                f'raise TemplateRuntimeError(\"Required block {node.name!r} not found\")',\n                node,\n            )\n            self.outdent()\n\n        if not self.environment.is_async and frame.buffer is None:\n            self.writeline(\n                f\"yield from context.blocks[{node.name!r}][0]({context})\", node\n            )\n        else:\n            self.writeline(\n                f\"{self.choose_async()}for event in\"\n                f\" context.blocks[{node.name!r}][0]({context}):\",\n                node,\n            )\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n\n        self.outdent(level)\n\n    def visit_Extends(self, node: nodes.Extends, frame: Frame) -> None:\n        \"\"\"Calls the extender.\"\"\"\n        if not frame.toplevel:\n            self.fail(\"cannot use extend from a non top-level scope\", node.lineno)\n\n        # if the number of extends statements in general is zero so\n        # far, we don't have to add a check if something extended\n        # the template before this one.\n        if self.extends_so_far > 0:\n            # if we have a known extends we just add a template runtime\n            # error into the generated code.  We could catch that at compile\n            # time too, but i welcome it not to confuse users by throwing the\n            # same error at different times just \"because we can\".\n            if not self.has_known_extends:\n                self.writeline(\"if parent_template is not None:\")\n                self.indent()\n            self.writeline('raise TemplateRuntimeError(\"extended multiple times\")')\n\n            # if we have a known extends already we don't need that code here\n            # as we know that the template execution will end here.\n            if self.has_known_extends:\n                raise CompilerExit()\n            else:\n                self.outdent()\n\n        self.writeline(\"parent_template = environment.get_template(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        self.writeline(\"for name, parent_block in parent_template.blocks.items():\")\n        self.indent()\n        self.writeline(\"context.blocks.setdefault(name, []).append(parent_block)\")\n        self.outdent()\n\n        # if this extends statement was in the root level we can take\n        # advantage of that information and simplify the generated code\n        # in the top level from this point onwards\n        if frame.rootlevel:\n            self.has_known_extends = True\n\n        # and now we have one more\n        self.extends_so_far += 1\n\n    def visit_Include(self, node: nodes.Include, frame: Frame) -> None:\n        \"\"\"Handles includes.\"\"\"\n        if node.ignore_missing:\n            self.writeline(\"try:\")\n            self.indent()\n\n        func_name = \"get_or_select_template\"\n        if isinstance(node.template, nodes.Const):\n            if isinstance(node.template.value, str):\n                func_name = \"get_template\"\n            elif isinstance(node.template.value, (tuple, list)):\n                func_name = \"select_template\"\n        elif isinstance(node.template, (nodes.Tuple, nodes.List)):\n            func_name = \"select_template\"\n\n        self.writeline(f\"template = environment.{func_name}(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        if node.ignore_missing:\n            self.outdent()\n            self.writeline(\"except TemplateNotFound:\")\n            self.indent()\n            self.writeline(\"pass\")\n            self.outdent()\n            self.writeline(\"else:\")\n            self.indent()\n\n        skip_event_yield = False\n        if node.with_context:\n            self.writeline(\n                f\"{self.choose_async()}for event in template.root_render_func(\"\n                \"template.new_context(context.get_all(), True,\"\n                f\" {self.dump_local_context(frame)})):\"\n            )\n        elif self.environment.is_async:\n            self.writeline(\n                \"for event in (await template._get_default_module_async())\"\n                \"._body_stream:\"\n            )\n        else:\n            self.writeline(\"yield from template._get_default_module()._body_stream\")\n            skip_event_yield = True\n\n        if not skip_event_yield:\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n\n        if node.ignore_missing:\n            self.outdent()\n\n    def _import_common(\n        self, node: t.Union[nodes.Import, nodes.FromImport], frame: Frame\n    ) -> None:\n        self.write(f\"{self.choose_async('await ')}environment.get_template(\")\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r}).\")\n\n        if node.with_context:\n            f_name = f\"make_module{self.choose_async('_async')}\"\n            self.write(\n                f\"{f_name}(context.get_all(), True, {self.dump_local_context(frame)})\"\n            )\n        else:\n            self.write(f\"_get_default_module{self.choose_async('_async')}(context)\")\n\n    def visit_Import(self, node: nodes.Import, frame: Frame) -> None:\n        \"\"\"Visit regular imports.\"\"\"\n        self.writeline(f\"{frame.symbols.ref(node.target)} = \", node)\n        if frame.toplevel:\n            self.write(f\"context.vars[{node.target!r}] = \")\n\n        self._import_common(node, frame)\n\n        if frame.toplevel and not node.target.startswith(\"_\"):\n            self.writeline(f\"context.exported_vars.discard({node.target!r})\")\n\n    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -> None:\n        \"\"\"Visit named imports.\"\"\"\n        self.newline(node)\n        self.write(\"included_template = \")\n        self._import_common(node, frame)\n        var_names = []\n        discarded_names = []\n        for name in node.names:\n            if isinstance(name, tuple):\n                name, alias = name\n            else:\n                alias = name\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} =\"\n                f\" getattr(included_template, {name!r}, missing)\"\n            )\n            self.writeline(f\"if {frame.symbols.ref(alias)} is missing:\")\n            self.indent()\n            # The position will contain the template name, and will be formatted\n            # into a string that will be compiled into an f-string. Curly braces\n            # in the name must be replaced with escapes so that they will not be\n            # executed as part of the f-string.\n            position = self.position(node).replace(\"{\", \"{{\").replace(\"}\", \"}}\");\n            message = (\n                \"the template {included_template.__name__!r}\"\n                f\" (imported on {position})\"\n                f\" does not export the requested name {name!r}\"\n            )\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})\"\n            )\n            self.outdent()\n            if frame.toplevel:\n                var_names.append(alias)\n                if not alias.startswith(\"_\"):\n                    discarded_names.append(alias)\n\n        if var_names:\n            if len(var_names) == 1:\n                name = var_names[0]\n                self.writeline(f\"context.vars[{name!r}] = {frame.symbols.ref(name)}\")\n            else:\n                names_kv = \", \".join(\n                    f\"{name!r}: {frame.symbols.ref(name)}\" for name in var_names\n                )\n                self.writeline(f\"context.vars.update({{{names_kv}}})\")\n        if discarded_names:\n            if len(discarded_names) == 1:\n                self.writeline(f\"context.exported_vars.discard({discarded_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, discarded_names))\n                self.writeline(\n                    f\"context.exported_vars.difference_update(({names_str}))\"\n                )\n\n    def visit_For(self, node: nodes.For, frame: Frame) -> None:\n        loop_frame = frame.inner()\n        loop_frame.loop_frame = True\n        test_frame = frame.inner()\n        else_frame = frame.inner()\n\n        # try to figure out if we have an extended loop.  An extended loop\n        # is necessary if the loop is in recursive mode if the special loop\n        # variable is accessed in the body if the body is a scoped block.\n        extended_loop = (\n            node.recursive\n            or \"loop\"\n            in find_undeclared(node.iter_child_nodes(only=(\"body\",)), (\"loop\",))\n            or any(block.scoped for block in node.find_all(nodes.Block))\n        )\n\n        loop_ref = None\n        if extended_loop:\n            loop_ref = loop_frame.symbols.declare_parameter(\"loop\")\n\n        loop_frame.symbols.analyze_node(node, for_branch=\"body\")\n        if node.else_:\n            else_frame.symbols.analyze_node(node, for_branch=\"else\")\n\n        if node.test:\n            loop_filter_func = self.temporary_identifier()\n            test_frame.symbols.analyze_node(node, for_branch=\"test\")\n            self.writeline(f\"{self.func(loop_filter_func)}(fiter):\", node.test)\n            self.indent()\n            self.enter_frame(test_frame)\n            self.writeline(self.choose_async(\"async for \", \"for \"))\n            self.visit(node.target, loop_frame)\n            self.write(\" in \")\n            self.write(self.choose_async(\"auto_aiter(fiter)\", \"fiter\"))\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"if \", node.test)\n            self.visit(node.test, test_frame)\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"yield \")\n            self.visit(node.target, loop_frame)\n            self.outdent(3)\n            self.leave_frame(test_frame, with_python_scope=True)\n\n        # if we don't have an recursive loop we have to find the shadowed\n        # variables at that point.  Because loops can be nested but the loop\n        # variable is a special one we have to enforce aliasing for it.\n        if node.recursive:\n            self.writeline(\n                f\"{self.func('loop')}(reciter, loop_render_func, depth=0):\", node\n            )\n            self.indent()\n            self.buffer(loop_frame)\n\n            # Use the same buffer for the else frame\n            else_frame.buffer = loop_frame.buffer\n\n        # make sure the loop variable is a special one and raise a template\n        # assertion error if a loop tries to write to loop\n        if extended_loop:\n            self.writeline(f\"{loop_ref} = missing\")\n\n        for name in node.find_all(nodes.Name):\n            if name.ctx == \"store\" and name.name == \"loop\":\n                self.fail(\n                    \"Can't assign to special loop variable in for-loop target\",\n                    name.lineno,\n                )\n\n        if node.else_:\n            iteration_indicator = self.temporary_identifier()\n            self.writeline(f\"{iteration_indicator} = 1\")\n\n        self.writeline(self.choose_async(\"async for \", \"for \"), node)\n        self.visit(node.target, loop_frame)\n        if extended_loop:\n            self.write(f\", {loop_ref} in {self.choose_async('Async')}LoopContext(\")\n        else:\n            self.write(\" in \")\n\n        if node.test:\n            self.write(f\"{loop_filter_func}(\")\n        if node.recursive:\n            self.write(\"reciter\")\n        else:\n            if self.environment.is_async and not extended_loop:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async and not extended_loop:\n                self.write(\")\")\n        if node.test:\n            self.write(\")\")\n\n        if node.recursive:\n            self.write(\", undefined, loop_render_func, depth):\")\n        else:\n            self.write(\", undefined):\" if extended_loop else \":\")\n\n        self.indent()\n        self.enter_frame(loop_frame)\n\n        self.writeline(\"_loop_vars = {}\")\n        self.blockvisit(node.body, loop_frame)\n        if node.else_:\n            self.writeline(f\"{iteration_indicator} = 0\")\n        self.outdent()\n        self.leave_frame(\n            loop_frame, with_python_scope=node.recursive and not node.else_\n        )\n\n        if node.else_:\n            self.writeline(f\"if {iteration_indicator}:\")\n            self.indent()\n            self.enter_frame(else_frame)\n            self.blockvisit(node.else_, else_frame)\n            self.leave_frame(else_frame)\n            self.outdent()\n\n        # if the node was recursive we have to return the buffer contents\n        # and start the iteration code\n        if node.recursive:\n            self.return_buffer_contents(loop_frame)\n            self.outdent()\n            self.start_write(frame, node)\n            self.write(f\"{self.choose_async('await ')}loop(\")\n            if self.environment.is_async:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async:\n                self.write(\")\")\n            self.write(\", loop)\")\n            self.end_write(frame)\n\n        # at the end of the iteration, clear any assignments made in the\n        # loop from the top level\n        if self._assign_stack:\n            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)\n\n    def visit_If(self, node: nodes.If, frame: Frame) -> None:\n        if_frame = frame.soft()\n        self.writeline(\"if \", node)\n        self.visit(node.test, if_frame)\n        self.write(\":\")\n        self.indent()\n        self.blockvisit(node.body, if_frame)\n        self.outdent()\n        for elif_ in node.elif_:\n            self.writeline(\"elif \", elif_)\n            self.visit(elif_.test, if_frame)\n            self.write(\":\")\n            self.indent()\n            self.blockvisit(elif_.body, if_frame)\n            self.outdent()\n        if node.else_:\n            self.writeline(\"else:\")\n            self.indent()\n            self.blockvisit(node.else_, if_frame)\n            self.outdent()\n\n    def visit_Macro(self, node: nodes.Macro, frame: Frame) -> None:\n        macro_frame, macro_ref = self.macro_body(node, frame)\n        self.newline()\n        if frame.toplevel:\n            if not node.name.startswith(\"_\"):\n                self.write(f\"context.exported_vars.add({node.name!r})\")\n            self.writeline(f\"context.vars[{node.name!r}] = \")\n        self.write(f\"{frame.symbols.ref(node.name)} = \")\n        self.macro_def(macro_ref, macro_frame)\n\n    def visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -> None:\n        call_frame, macro_ref = self.macro_body(node, frame)\n        self.writeline(\"caller = \")\n        self.macro_def(macro_ref, call_frame)\n        self.start_write(frame, node)\n        self.visit_Call(node.call, frame, forward_caller=True)\n        self.end_write(frame)\n\n    def visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -> None:\n        filter_frame = frame.inner()\n        filter_frame.symbols.analyze_node(node)\n        self.enter_frame(filter_frame)\n        self.buffer(filter_frame)\n        self.blockvisit(node.body, filter_frame)\n        self.start_write(frame, node)\n        self.visit_Filter(node.filter, filter_frame)\n        self.end_write(frame)\n        self.leave_frame(filter_frame)\n\n    def visit_With(self, node: nodes.With, frame: Frame) -> None:\n        with_frame = frame.inner()\n        with_frame.symbols.analyze_node(node)\n        self.enter_frame(with_frame)\n        for target, expr in zip(node.targets, node.values):\n            self.newline()\n            self.visit(target, with_frame)\n            self.write(\" = \")\n            self.visit(expr, frame)\n        self.blockvisit(node.body, with_frame)\n        self.leave_frame(with_frame)\n\n    def visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -> None:\n        self.newline(node)\n        self.visit(node.node, frame)\n\n    class _FinalizeInfo(t.NamedTuple):\n        const: t.Optional[t.Callable[..., str]]\n        src: t.Optional[str]\n\n    @staticmethod\n    def _default_finalize(value: t.Any) -> t.Any:\n        \"\"\"The default finalize function if the environment isn't\n        configured with one. Or, if the environment has one, this is\n        called on that function's output for constants.\n        \"\"\"\n        return str(value)\n\n    _finalize: t.Optional[_FinalizeInfo] = None\n\n    def _make_finalize(self) -> _FinalizeInfo:\n        \"\"\"Build the finalize function to be used on constants and at\n        runtime. Cached so it's only created once for all output nodes.\n\n        Returns a ``namedtuple`` with the following attributes:\n\n        ``const``\n            A function to finalize constant data at compile time.\n\n        ``src``\n            Source code to output around nodes to be evaluated at\n            runtime.\n        \"\"\"\n        if self._finalize is not None:\n            return self._finalize\n\n        finalize: t.Optional[t.Callable[..., t.Any]]\n        finalize = default = self._default_finalize\n        src = None\n\n        if self.environment.finalize:\n            src = \"environment.finalize(\"\n            env_finalize = self.environment.finalize\n            pass_arg = {\n                _PassArg.context: \"context\",\n                _PassArg.eval_context: \"context.eval_ctx\",\n                _PassArg.environment: \"environment\",\n            }.get(\n                _PassArg.from_obj(env_finalize)  # type: ignore\n            )\n            finalize = None\n\n            if pass_arg is None:\n\n                def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                    return default(env_finalize(value))\n\n            else:\n                src = f\"{src}{pass_arg}, \"\n\n                if pass_arg == \"environment\":\n\n                    def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                        return default(env_finalize(self.environment, value))\n\n        self._finalize = self._FinalizeInfo(finalize, src)\n        return self._finalize\n\n    def _output_const_repr(self, group: t.Iterable[t.Any]) -> str:\n        \"\"\"Given a group of constant values converted from ``Output``\n        child nodes, produce a string to write to the template module\n        source.\n        \"\"\"\n        return repr(concat(group))\n\n    def _output_child_to_const(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> str:\n        \"\"\"Try to optimize a child of an ``Output`` node by trying to\n        convert it to constant, finalized data at compile time.\n\n        If :exc:`Impossible` is raised, the node is not constant and\n        will be evaluated at runtime. Any other exception will also be\n        evaluated at runtime for easier debugging.\n        \"\"\"\n        const = node.as_const(frame.eval_ctx)\n\n        if frame.eval_ctx.autoescape:\n            const = escape(const)\n\n        # Template data doesn't go through finalize.\n        if isinstance(node, nodes.TemplateData):\n            return str(const)\n\n        return finalize.const(const)  # type: ignore\n\n    def _output_child_pre(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code before visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        if frame.eval_ctx.volatile:\n            self.write(\"(escape if context.eval_ctx.autoescape else str)(\")\n        elif frame.eval_ctx.autoescape:\n            self.write(\"escape(\")\n        else:\n            self.write(\"str(\")\n\n        if finalize.src is not None:\n            self.write(finalize.src)\n\n    def _output_child_post(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code after visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        self.write(\")\")\n\n        if finalize.src is not None:\n            self.write(\")\")\n\n    def visit_Output(self, node: nodes.Output, frame: Frame) -> None:\n        # If an extends is active, don't render outside a block.\n        if frame.require_output_check:\n            # A top-level extends is known to exist at compile time.\n            if self.has_known_extends:\n                return\n\n            self.writeline(\"if parent_template is None:\")\n            self.indent()\n\n        finalize = self._make_finalize()\n        body: t.List[t.Union[t.List[t.Any], nodes.Expr]] = []\n\n        # Evaluate constants at compile time if possible. Each item in\n        # body will be either a list of static data or a node to be\n        # evaluated at runtime.\n        for child in node.nodes:\n            try:\n                if not (\n                    # If the finalize function requires runtime context,\n                    # constants can't be evaluated at compile time.\n                    finalize.const\n                    # Unless it's basic template data that won't be\n                    # finalized anyway.\n                    or isinstance(child, nodes.TemplateData)\n                ):\n                    raise nodes.Impossible()\n\n                const = self._output_child_to_const(child, frame, finalize)\n            except (nodes.Impossible, Exception):\n                # The node was not constant and needs to be evaluated at\n                # runtime. Or another error was raised, which is easier\n                # to debug at runtime.\n                body.append(child)\n                continue\n\n            if body and isinstance(body[-1], list):\n                body[-1].append(const)\n            else:\n                body.append([const])\n\n        if frame.buffer is not None:\n            if len(body) == 1:\n                self.writeline(f\"{frame.buffer}.append(\")\n            else:\n                self.writeline(f\"{frame.buffer}.extend((\")\n\n            self.indent()\n\n        for item in body:\n            if isinstance(item, list):\n                # A group of constant data to join and output.\n                val = self._output_const_repr(item)\n\n                if frame.buffer is None:\n                    self.writeline(\"yield \" + val)\n                else:\n                    self.writeline(val + \",\")\n            else:\n                if frame.buffer is None:\n                    self.writeline(\"yield \", item)\n                else:\n                    self.newline(item)\n\n                # A node to be evaluated at runtime.\n                self._output_child_pre(item, frame, finalize)\n                self.visit(item, frame)\n                self._output_child_post(item, frame, finalize)\n\n                if frame.buffer is not None:\n                    self.write(\",\")\n\n        if frame.buffer is not None:\n            self.outdent()\n            self.writeline(\")\" if len(body) == 1 else \"))\")\n\n        if frame.require_output_check:\n            self.outdent()\n\n    def visit_Assign(self, node: nodes.Assign, frame: Frame) -> None:\n        self.push_assign_tracking()\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = \")\n        self.visit(node.node, frame)\n        self.pop_assign_tracking(frame)\n\n    def visit_AssignBlock(self, node: nodes.AssignBlock, frame: Frame) -> None:\n        self.push_assign_tracking()\n        block_frame = frame.inner()\n        # This is a special case.  Since a set block always captures we\n        # will disable output checks.  This way one can use set blocks\n        # toplevel even in extended templates.\n        block_frame.require_output_check = False\n        block_frame.symbols.analyze_node(node)\n        self.enter_frame(block_frame)\n        self.buffer(block_frame)\n        self.blockvisit(node.body, block_frame)\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = (Markup if context.eval_ctx.autoescape else identity)(\")\n        if node.filter is not None:\n            self.visit_Filter(node.filter, block_frame)\n        else:\n            self.write(f\"concat({block_frame.buffer})\")\n        self.write(\")\")\n        self.pop_assign_tracking(frame)\n        self.leave_frame(block_frame)\n\n    # -- Expression Visitors\n\n    def visit_Name(self, node: nodes.Name, frame: Frame) -> None:\n        if node.ctx == \"store\" and (\n            frame.toplevel or frame.loop_frame or frame.block_frame\n        ):\n            if self._assign_stack:\n                self._assign_stack[-1].add(node.name)\n        ref = frame.symbols.ref(node.name)\n\n        # If we are looking up a variable we might have to deal with the\n        # case where it's undefined.  We can skip that case if the load\n        # instruction indicates a parameter which are always defined.\n        if node.ctx == \"load\":\n            load = frame.symbols.find_load(ref)\n            if not (\n                load is not None\n                and load[0] == VAR_LOAD_PARAMETER\n                and not self.parameter_is_undeclared(ref)\n            ):\n                self.write(\n                    f\"(undefined(name={node.name!r}) if {ref} is missing else {ref})\"\n                )\n                return\n\n        self.write(ref)\n\n    def visit_NSRef(self, node: nodes.NSRef, frame: Frame) -> None:\n        # NSRefs can only be used to store values; since they use the normal\n        # `foo.bar` notation they will be parsed as a normal attribute access\n        # when used anywhere but in a `set` context\n        ref = frame.symbols.ref(node.name)\n        self.writeline(f\"if not isinstance({ref}, Namespace):\")\n        self.indent()\n        self.writeline(\n            \"raise TemplateRuntimeError\"\n            '(\"cannot assign attribute on non-namespace object\")'\n        )\n        self.outdent()\n        self.writeline(f\"{ref}[{node.attr!r}]\")\n\n    def visit_Const(self, node: nodes.Const, frame: Frame) -> None:\n        val = node.as_const(frame.eval_ctx)\n        if isinstance(val, float):\n            self.write(str(val))\n        else:\n            self.write(repr(val))\n\n    def visit_TemplateData(self, node: nodes.TemplateData, frame: Frame) -> None:\n        try:\n            self.write(repr(node.as_const(frame.eval_ctx)))\n        except nodes.Impossible:\n            self.write(\n                f\"(Markup if context.eval_ctx.autoescape else identity)({node.data!r})\"\n            )\n\n    def visit_Tuple(self, node: nodes.Tuple, frame: Frame) -> None:\n        self.write(\"(\")\n        idx = -1\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\",)\" if idx == 0 else \")\")\n\n    def visit_List(self, node: nodes.List, frame: Frame) -> None:\n        self.write(\"[\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\"]\")\n\n    def visit_Dict(self, node: nodes.Dict, frame: Frame) -> None:\n        self.write(\"{\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item.key, frame)\n            self.write(\": \")\n            self.visit(item.value, frame)\n        self.write(\"}\")\n\n    visit_Add = _make_binop(\"+\")\n    visit_Sub = _make_binop(\"-\")\n    visit_Mul = _make_binop(\"*\")\n    visit_Div = _make_binop(\"/\")\n    visit_FloorDiv = _make_binop(\"//\")\n    visit_Pow = _make_binop(\"**\")\n    visit_Mod = _make_binop(\"%\")\n    visit_And = _make_binop(\"and\")\n    visit_Or = _make_binop(\"or\")\n    visit_Pos = _make_unop(\"+\")\n    visit_Neg = _make_unop(\"-\")\n    visit_Not = _make_unop(\"not \")\n\n    @optimizeconst\n    def visit_Concat(self, node: nodes.Concat, frame: Frame) -> None:\n        if frame.eval_ctx.volatile:\n            func_name = \"(markup_join if context.eval_ctx.volatile else str_join)\"\n        elif frame.eval_ctx.autoescape:\n            func_name = \"markup_join\"\n        else:\n            func_name = \"str_join\"\n        self.write(f\"{func_name}((\")\n        for arg in node.nodes:\n            self.visit(arg, frame)\n            self.write(\", \")\n        self.write(\"))\")\n\n    @optimizeconst\n    def visit_Compare(self, node: nodes.Compare, frame: Frame) -> None:\n        self.write(\"(\")\n        self.visit(node.expr, frame)\n        for op in node.ops:\n            self.visit(op, frame)\n        self.write(\")\")\n\n    def visit_Operand(self, node: nodes.Operand, frame: Frame) -> None:\n        self.write(f\" {operators[node.op]} \")\n        self.visit(node.expr, frame)\n\n    @optimizeconst\n    def visit_Getattr(self, node: nodes.Getattr, frame: Frame) -> None:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n\n        self.write(\"environment.getattr(\")\n        self.visit(node.node, frame)\n        self.write(f\", {node.attr!r})\")\n\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    @optimizeconst\n    def visit_Getitem(self, node: nodes.Getitem, frame: Frame) -> None:\n        # slices bypass the environment getitem method.\n        if isinstance(node.arg, nodes.Slice):\n            self.visit(node.node, frame)\n            self.write(\"[\")\n            self.visit(node.arg, frame)\n            self.write(\"]\")\n        else:\n            if self.environment.is_async:\n                self.write(\"(await auto_await(\")\n\n            self.write(\"environment.getitem(\")\n            self.visit(node.node, frame)\n            self.write(\", \")\n            self.visit(node.arg, frame)\n            self.write(\")\")\n\n            if self.environment.is_async:\n                self.write(\"))\")\n\n    def visit_Slice(self, node: nodes.Slice, frame: Frame) -> None:\n        if node.start is not None:\n            self.visit(node.start, frame)\